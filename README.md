# Цель — прочувствовать разницу между “имя переменной — значение” и “указатель — адрес → значение”.

---

## Уровень 1 — базовые “игры с адресами”

1. Объяви:

```cpp
int a = 10;
int* p = &a;
```

* Выведи `a`, `&a`, `p` и `*p`.
* Затем присвой `*p = 20;`. Выведи `a` снова. Объясни, почему изменилось.

2. Объяви две переменные:

```cpp
int x = 5;
int y = 7;
int* px = &x;
```

* Выведи `*px` (значение, на которое указывает `px`).
* Затем присвой `px = &y;`, выведи `*px`.
* Затем присвой `*px = 42;`. Выведи `y`. Что произошло?

3. Использование “нулевого” указателя:

```cpp
int* p = nullptr;
```

* Попытайся вывести `p` и `*p`. Что из этого корректно? Почему `*p` — ошибка (или неопределённое поведение).

---

## Уровень 2 — “перенаправление” и копии указателей

4. Объяви:

```cpp
int a = 100;
int* p1 = &a;
int* p2 = p1;
```

* Выведи `p1` и `p2`. Они должны быть равны (указывают на один адрес).
* Выведи `*p1` и `*p2`. Изменяй `*p2 = 200;` и проверь `a`, `*p1`.

5. Поменяй местами значения через указатели:

```cpp
int a = 3, b = 7;
int* p = &a;
int* q = &b;
```

* Используй только `*p` и `*q`, чтобы поменять `a` и `b` так, чтобы `a` стало 7, `b` стало 3.
* Выведи `a` и `b` после.

---

## Уровень 3 — чуть более “продвинутые”, но всё ещё без циклов/ветвлений

6. Комбинации:

```cpp
int a = 1, b = 2, c = 3;
int *p = &a;
```

* Присвой `p = &b;`. Затем `*p = c;`. Выведи `a, b, c`.
* Присвой `p = &c;`. Затем `*p = a + b;` — хотя здесь “a + b” уже выражение, но пусть это будет просто присваивание “внешнего значения” (если ты посчитал заранее). Выведи `c`.

7. Неявная “переименование”:

```cpp
int a = 10;
int* p = &a;
int& r = *p;  // здесь ссылка к “ячейке, на которую указывает p”
```

* Выведи `a`, `r`, `p`, `&r`, `&a`.
* Затем присвой `r = 20;`. Выведи `a`. Что изменилось?

---
